"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.jsonPathString=exports.recurseObject=exports.findReferencedPaths=exports.renderObject=exports.JsonPathToken=void 0;const core_1=require("../../core"),JSON_PATH_TOKEN_SYMBOL=Symbol.for("@aws-cdk/aws-stepfunctions.JsonPathToken");class JsonPathToken{constructor(path){this.path=path,this.creationStack=core_1.captureStackTrace(),this.displayHint=path.replace(/^[^a-zA-Z]+/,""),Object.defineProperty(this,JSON_PATH_TOKEN_SYMBOL,{value:!0})}static isJsonPathToken(x){return x[JSON_PATH_TOKEN_SYMBOL]===!0}resolve(_ctx){return this.path}toString(){return core_1.Token.asString(this,{displayHint:this.displayHint})}toJSON(){return`<path:${this.path}>`}}exports.JsonPathToken=JsonPathToken;function renderObject(obj){return recurseObject(obj,{handleString:renderString,handleList:renderStringList,handleNumber:renderNumber,handleBoolean:renderBoolean})}exports.renderObject=renderObject;function findReferencedPaths(obj){const found=new Set;return recurseObject(obj,{handleString(_key,x){const path=jsonPathString(x);return path!==void 0&&found.add(path),{}},handleList(_key,x){const path=jsonPathStringList(x);return path!==void 0&&found.add(path),{}},handleNumber(_key,x){const path=jsonPathNumber(x);return path!==void 0&&found.add(path),{}},handleBoolean(_key,_x){return{}}}),found}exports.findReferencedPaths=findReferencedPaths;function recurseObject(obj,handlers,visited=[]){if(typeof obj!="object"||obj===null)return obj;if(visited.includes(obj))return{};visited.push(obj);const ret={};for(const[key,value]of Object.entries(obj))typeof value=="string"?Object.assign(ret,handlers.handleString(key,value)):typeof value=="number"?Object.assign(ret,handlers.handleNumber(key,value)):Array.isArray(value)?Object.assign(ret,recurseArray(key,value,handlers,visited)):typeof value=="boolean"?Object.assign(ret,handlers.handleBoolean(key,value)):value==null||typeof value=="object"&&(ret[key]=recurseObject(value,handlers,visited));return visited.pop(),ret}exports.recurseObject=recurseObject;function recurseArray(key,arr,handlers,visited=[]){return isStringArray(arr)&&jsonPathStringList(arr)!==void 0?handlers.handleList(key,arr):{[key]:arr.map(value=>{if(typeof value=="string"&&jsonPathString(value)!==void 0||typeof value=="number"&&jsonPathNumber(value)!==void 0||isStringArray(value)&&jsonPathStringList(value)!==void 0)throw new Error("Cannot use JsonPath fields in an array, they must be used in objects");return typeof value=="object"&&value!==null?recurseObject(value,handlers,visited):value})}}function isStringArray(x){return Array.isArray(x)&&x.every(el=>typeof el=="string")}function renderString(key,value){const path=jsonPathString(value);return path!==void 0?{[key+".$"]:path}:{[key]:value}}function renderStringList(key,value){const path=jsonPathStringList(value);return path!==void 0?{[key+".$"]:path}:{[key]:value}}function renderNumber(key,value){const path=jsonPathNumber(value);return path!==void 0?{[key+".$"]:path}:{[key]:value}}function renderBoolean(key,value){return{[key]:value}}function jsonPathString(x){const fragments=core_1.Tokenization.reverseString(x),jsonPathTokens=fragments.tokens.filter(JsonPathToken.isJsonPathToken);if(jsonPathTokens.length>0&&fragments.length>1)throw new Error(`Field references must be the entire string, cannot concatenate them (found '${x}')`);if(jsonPathTokens.length>0)return jsonPathTokens[0].path}exports.jsonPathString=jsonPathString;function jsonPathStringList(x){return pathFromToken(core_1.Tokenization.reverseList(x))}function jsonPathNumber(x){return pathFromToken(core_1.Tokenization.reverseNumber(x))}function pathFromToken(token){return token&&(JsonPathToken.isJsonPathToken(token)?token.path:void 0)}
//# sourceMappingURL=json-path.js.map
